<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbulb with Three.js and GLSL</title>
<style>
body, html {margin:0;padding:0;overflow:hidden;width:100%;height:100%;}
* {font-family:verdana;font-size:14;margin:0;padding:0;}
canvas1 {display:block;}
div.MBMenu {position:fixed;padding:0px;border-width:0px;background-color:rgba(0,1,0,0.1);width:525px;height:40px;top:50px;left:50px;color:white;}
.MBMenu2 {position:fixed;font-size:12px;color:#AAA;padding:0px;border-width:0px;background-color:rgba(1,0,1,0.8);width:220px;height:36px;text-align:center;top:41px;right:50px;padding:10px;}
.MBMenuOpt {float:left;border-width:0px;background-color:rgba(1,0,1,0.8);width:105px;height:40px;color:white;text-align:center;line-height:40px;}
.MBMenuOpt:hover {background-color:rgba(255,255,255,0.8);color:black;}
.MBPanel {position:fixed;border-width:0px;padding:10;background-color:rgba(0,0,0,0.5);width:505px;top:90px;left:50px;color:white;}
.MBLabel {padding:2px;width:120px;float:left;}
.MBInput {padding:2px;width:120px;style="text-align:right";}
.MBColourInput {padding:0px;width:120px;}
a {color:#FFF;font-size:16px;text-decoration:none;}
a:hover {color:#F93;}
</style>
</head>
<body>
      <script src="https://threejs.org/build/three.js"></script> 
<!--  <script src="three.js"></script>-->
	<script id="vertexShader" type="x-shader/x-vertex">
    void main() {
        gl_Position = vec4(position, 1.0);
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
precision mediump float;

uniform vec2 resolution; // Dimensions of the viewport
uniform float fov;      // Field of view (in radians)
uniform vec3 cameraPosition2;
uniform vec3 cameraTarget;
uniform float baseEpsilonFactor;
uniform float power;
uniform int iterations;
uniform bool depthCheck;
uniform vec2 depthXY;
uniform bool juliaMode;
uniform bool screenSpaceDE;
uniform vec3 juliaStart;
uniform int estimateIterations;
uniform float DEFactor;
uniform bool XOrbitColour;
uniform bool YOrbitColour;
uniform bool ZOrbitColour;
uniform vec3 XBColour;
uniform vec3 YBColour;
uniform vec3 ZBColour;
uniform vec3 XEColour;
uniform vec3 YEColour;
uniform vec3 ZEColour;
uniform bool HSLBlend;
uniform bool sliceFractal;
uniform float sliceHeight;

mat3 constructCameraBasis(vec3 cameraPos, vec3 target, vec3 up) {
    vec3 forward = normalize(cameraPos - target);
    vec3 right = normalize(cross(up, forward));
    vec3 newUp = cross(forward, right);
    return mat3(right, newUp, forward);
}

// Sphere signed distance function
float sphereSDF(vec3 point, vec3 center, float radius) {
    return length(point - center) - radius;
}

float mandelbulbDE(vec3 pos, out vec4 trap) {
    int maxIterations = iterations;
    const float escapeBound = 2.0;

    vec3 z = pos.xzy;

    float dr = 1.0;
    float r = 0.0;
	float theta, phi;
	
	trap = vec4(abs(z),0.0);

    for (int i = 0; i < maxIterations; i++) {
       r = length(z);
        if (r > escapeBound) break;
		
		float theta = atan(z.y / z.x);
		float phi = asin(z.z / r);
        dr = pow(r, power - 1.0) * power * dr + 1.0;

        // Scale and rotate the point
        float zr = pow(r, power);
        theta = theta * power;
        phi = phi * power;

        // Convert back to cartesian coordinates
        z = zr * vec3(cos(theta) * cos(phi), cos(phi) * sin(theta), sin(phi));
		if (juliaMode)
			z += juliaStart;
        else
			z += pos.xzy;
	    trap = vec4(min(trap.xyz, abs(z)), i);
    }

    return 0.5 * log(r) * r / dr;
}

float distanceEstimate(vec3 point, out vec4 trap) {
    return mandelbulbDE(point, trap);
}

vec3 estimateNormal(vec3 point) {
    const float eps = 0.0001;
	vec4 trap;
    float dx = distanceEstimate(point + vec3(eps, 0.0, 0.0), trap) - distanceEstimate(point - vec3(eps, 0.0, 0.0), trap);
    float dy = distanceEstimate(point + vec3(0.0, eps, 0.0), trap) - distanceEstimate(point - vec3(0.0, eps, 0.0), trap);
    float dz = distanceEstimate(point + vec3(0.0, 0.0, eps), trap) - distanceEstimate(point - vec3(0.0, 0.0, eps), trap);
    return normalize(vec3(dx, dy, dz));
}

float softShadow(vec3 ro, vec3 rd, float start, float end) {
    float res = 1.0;
    float t = start;
    for (int i = 0; i < 50; i++) {
		vec4 trap;
        float h = distanceEstimate(ro + rd * t, trap);
        if (h < 0.001) return 0.0;  // Fully in shadow
        res = min(res, 8.0 * h / t);
        t += h;
        if (t > end) break;
    }
    return res;
}

// Function to convert RGB to HSL
vec3 rgb2hsl(vec3 c) {
    float maxVal = max(c.r, max(c.g, c.b));
    float minVal = min(c.r, min(c.g, c.b));
    float l = (maxVal + minVal) / 2.0;

    if (maxVal == minVal) {
        return vec3(0.0, 0.0, l);
    }

    float d = maxVal - minVal;
    float s = l > 0.5 ? d / (2.0 - maxVal - minVal) : d / (maxVal + minVal);
    float h;

    if (maxVal == c.r) {
        h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);
    } else if (maxVal == c.g) {
        h = (c.b - c.r) / d + 2.0;
    } else {
        h = (c.r - c.g) / d + 4.0;
    }

    h /= 6.0;

    return vec3(h, s, l);
}

float hue2rgb(float p, float q, float t) {
	if (t < 0.0) t += 1.0;
	if (t > 1.0) t -= 1.0;
	if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;
	if (t < 0.5) return q;
	if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;
	return p;
}

// Function to convert HSL to RGB
vec3 hsl2rgb(vec3 c) {
    float r, g, b;

    if (c.y == 0.0) {
        r = g = b = c.z; // achromatic
    } else {
        float q = c.z < 0.5 ? c.z * (1.0 + c.y) : c.z + c.y - c.z * c.y;
        float p = 2.0 * c.z - q;


        r = hue2rgb(p, q, c.x + 1.0 / 3.0);
        g = hue2rgb(p, q, c.x);
        b = hue2rgb(p, q, c.x - 1.0 / 3.0);
    }

    return vec3(r, g, b);
}

vec3 GetFractalColour(vec4 trap) {
	vec3 trapColour = vec3(0.0, 0.0, 0.0);
	if (HSLBlend) {
	    vec3 hsl1, hsl2, hsl3;
		if (XOrbitColour)
		{
		 hsl1 = mix(rgb2hsl(XBColour), rgb2hsl(XEColour), trap.x);
		}
		if (YOrbitColour)
		{
		 hsl2 = mix(rgb2hsl(YBColour), rgb2hsl(YEColour), trap.y);
		}
		if (ZOrbitColour)
		{
		 hsl3 = mix(rgb2hsl(ZBColour), rgb2hsl(ZEColour), trap.z);
		}
		vec3 sum = (XOrbitColour?hsl1:vec3(0,0,0)) + 
			(YOrbitColour?hsl2:vec3(0,0,0)) + 
			(ZOrbitColour?hsl3:vec3(0,0,0));
		sum /= (XOrbitColour?1.0:0.0)+(YOrbitColour?1.0:0.0)+(ZOrbitColour?1.0:0.0);
		sum.x = (XOrbitColour?hsl1.x*trap.x:0.0) + 
			(YOrbitColour?hsl2.x*trap.y:0.0) + 
			(ZOrbitColour?hsl3.x*trap.z:0.0);
		sum.x /= (XOrbitColour?trap.x:0.0)+(YOrbitColour?trap.y:0.0)+(ZOrbitColour?trap.z:0.0);
		
		trapColour = clamp(hsl2rgb(sum), 0.0, 1.0);
	}
	else {
		if (XOrbitColour)
		{
		 trapColour += trap.xxx * mix(XBColour, XEColour, trap.x);
		}
		if (YOrbitColour)
		{
		 trapColour += trap.yyy * mix(YBColour, YEColour, trap.y);
		}
		if (ZOrbitColour)
		{
		 trapColour += trap.zzz * mix(ZBColour, ZEColour, trap.z);
		}
		trapColour = clamp(trapColour, 0.0, 1.0);
	}
	return trapColour;
}

void main() {
	if (sliceFractal)
	{
	  vec2 normalizedCoord = (2.0*gl_FragCoord.xy - resolution) / min(resolution.y, resolution.x);
	  vec3 position = vec3(normalizedCoord.x, sliceHeight, normalizedCoord.y);
	  vec4 trap;
	  distanceEstimate(position, trap);
	  vec3 colour = vec3(1,1,1);//GetFractalColour(trap);
	  colour *= trap.w/float(iterations);
	  gl_FragColor = vec4(colour, 1.0);
	  return;
	}

    // 1. Normalize the 2D screen coordinates
    vec2 normalizedCoord = (2.0*gl_FragCoord.xy - resolution) / min(resolution.y, resolution.x);
    if (depthCheck)
	{
	 normalizedCoord = (2.0*depthXY - resolution) / min(resolution.y, resolution.x);
	}
	
//	gl_FragColor = vec4(normalizedCoord.x, normalizedCoord.y, 0, 1);return;
//	gl_FragColor = vec4(((gl_FragCoord.x-resolution.x) / min(resolution.y, resolution.x))*0.5 + 0.5, ((gl_FragCoord.y-resolution.y) / min(resolution.y, resolution.x))*0.5 + 0.5, 0, 1);return;

    // 2. Determine the point on the image plane in the camera space
    float imagePlaneZ = -1.0 / tan(fov * 0.5); // Negative because in most conventions, camera looks towards -Z in its local space.
    vec3 pointOnImagePlane = vec3(normalizedCoord, imagePlaneZ);
    
	// Construct the camera basis
	mat3 camBasis = constructCameraBasis(cameraPosition2, cameraTarget, vec3(0.0, 1.0, 0.0));

	// Transform the ray direction based on the camera basis
	vec3 transformedRayDir = camBasis * pointOnImagePlane;

	// Now, use this transformedRayDir for raymarching
	vec3 rayDirection = normalize(transformedRayDir);

    // 3. Construct the ray
    vec3 rayOrigin = cameraPosition2;
    
    // Raymarching setup
    float t = 0.0; 
    float maxDistance = 100.0;  // Maximum distance to march
    float minDist = 0.003;  // Minimum distance to consider a hit
    vec3 sphereCenter = vec3(0.0, 0.0, -5.0);  // Placing the sphere a bit into the scene
    float sphereRadius = 1.0;

    float epsilon = minDist*baseEpsilonFactor;
	vec4 trap;
		
	// Raymarching loop
    for (int i = 0; i < estimateIterations; i++) {  // Limit the number of iterations
        vec3 currentPoint = rayOrigin + t * rayDirection;
        float distance = distanceEstimate(currentPoint, trap);
		if (screenSpaceDE)
			epsilon = t / resolution.y * baseEpsilonFactor;
        
        if (distance < epsilon) {  // Close enough to consider it a hit
            break;}
        
		t += DEFactor*distance;  // Move along the ray
        if (t > maxDistance) {  // Exit if we've marched too far
            break;
        }
    }

   // Hemispherical ambient lighting
    vec3 skyColor = vec3(0.53, 0.81, 0.98); // Sky blue
    vec3 groundColor = vec3(0.1, 0.3, 0.1); // Black
	
	if (t < maxDistance) {
		vec3 hitPoint = rayOrigin + t * rayDirection;
		if (depthCheck)
		{
		 gl_FragColor = vec4(hitPoint, t);
		 return;
		}
		
		vec3 normal = estimateNormal(hitPoint);
		
		// Define a directional light source
		vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0)); // Example light direction
		
		// Calculate Lambertian reflectance
		float lambert = softShadow(hitPoint, lightDir, 0.05, 0.3) * max(0.0, dot(normal, lightDir));		
		vec3 ambientColor = mix(groundColor, skyColor, 0.5 + 0.5 * normal.y);
     
    // Combine lambertian and ambient lighting
    vec3 baseColor = vec3(0.8, 0.5, 0.3); 
	vec3 trapColour = GetFractalColour(trap);
    vec3 finalColor = trapColour * (ambientColor + lambert);
	gl_FragColor = vec4(finalColor, 1.0);
    } else {
		if (depthCheck)
		{
		 vec3 hitPoint = rayOrigin + 1000.0 * rayDirection;
		 gl_FragColor = vec4(hitPoint, -1.0);
		 return;
		}
     vec3 ambientColor = mix(groundColor, skyColor, 0.5 + 0.5 * rayDirection.y);
     gl_FragColor = vec4(ambientColor, 1.0);  // No hit, render black
    }
}
</script>

    <script>
	// Create a scene and a camera
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
let isDragging = false;
let isJuliaDragging = false;
let previousMousePosition = { x: 0, y: 0 };
let gJuliaLocation = { x: 0, y: 0, z: 0 };
let gOrbitLocation = { x: 0, y: 0, z: 0 };
let gPower = 8;
let gIterations = 30;
let gZoom = 1;
let gDirty = true;
let gJuliaDirty = true;
let gOrbitViewDirty = true;
let gOrbitMapDirty = true;
let gScreenSpaceDE = true;
let gBaseEpsilonFactor = 1.0;
let gEstimateIterations = 1000;
let gDEFactor = 0.5;
let gCameraFrom = { x: 0, y: 0, z: 3};
let gCameraTo = { x: 0, y: 0, z: 0};
let gFOV = Math.PI / 3;
let gSliceFractal = false;
let gSliceHeight = 0.0;
let gXOrbitColour = true;
let gYOrbitColour = true;
let gZOrbitColour = true;
let gXBColour = { r: 0.005, g: 0.0, b: 0.0}
let gYBColour = { r: 0.0, g: 0.005, b: 0.0}
let gZBColour = { r: 0.0, g: 0.0, b: 0.005}
let gXEColour = { r: 1.0, g: 0.0, b: 0.0}
let gYEColour = { r: 0.0, g: 1.0, b: 0.0}
let gZEColour = { r: 0.0, g: 0.0, b: 1.0}
let gHSLBlend = true;
let gJuliaMain = false;
let gJuliaDragSelection = false;

// Create a WebGL renderer
var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Shader material
var shaderMaterial = new THREE.ShaderMaterial({
    vertexShader: document.getElementById('vertexShader').textContent,
    fragmentShader: document.getElementById('fragmentShader').textContent,
    uniforms: {
        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        fov: { value: Math.PI / 3 },  // You can adjust this value as needed
        cameraTarget: { value: new THREE.Vector3(0.0, 0.0, 0.0) },     // Example values
        cameraPosition2: { value: new THREE.Vector3(0.0, 0.0, 3.0) },  // Example values
		baseEpsilonFactor: {value: 1.0 },
		screenSpaceDE: { value: true },
		power: {value: 8 },
		iterations: {value: 20 },
		depthCheck: { value: false },
		depthXY: { value: new THREE.Vector2(0, 0) },
		juliaMode: { value: false},
		juliaStart: { value: new THREE.Vector3(1.0, 0.0, 0.0) },
		estimateIterations: {value: 1000 },
		DEFactor: {value: 0.5 },
		XOrbitColour: { value : true},
		YOrbitColour: { value : true},
		ZOrbitColour: { value : true},
		XBColour: {value : new THREE.Vector3(0.0, 0.0, 0.0) },
		YBColour: {value : new THREE.Vector3(0.0, 0.0, 0.0) },
		ZBColour: {value : new THREE.Vector3(0.0, 0.0, 0.0) },
		XEColour: {value : new THREE.Vector3(1.0, 0.0, 0.0) },
		YEColour: {value : new THREE.Vector3(0.0, 1.0, 0.0) },
		ZEColour: {value : new THREE.Vector3(0.0, 0.0, 1.0) },
		HSLBlend : {value : true},
		sliceFractal: {value: false},
		sliceHeight: {value: 0.0 }
}});


// Create a mesh with the shader material
var geometry = new THREE.PlaneGeometry(2, 2);
var mesh = new THREE.Mesh(geometry, shaderMaterial);
scene.add(mesh);

// Position the camera
camera.position.z = 1;

function SetUniforms()
{
	shaderMaterial.uniforms.screenSpaceDE.value = gScreenSpaceDE;
	shaderMaterial.uniforms.baseEpsilonFactor.value = gBaseEpsilonFactor;
	shaderMaterial.uniforms.estimateIterations.value = gEstimateIterations;
	shaderMaterial.uniforms.DEFactor.value = gDEFactor;
	shaderMaterial.uniforms.XOrbitColour.value = gXOrbitColour;
	shaderMaterial.uniforms.YOrbitColour.value = gYOrbitColour;
	shaderMaterial.uniforms.ZOrbitColour.value = gZOrbitColour;
	shaderMaterial.uniforms.HSLBlend.value = gHSLBlend;
	shaderMaterial.uniforms.XBColour.value.set(gXBColour.r, gXBColour.g, gXBColour.b);
	shaderMaterial.uniforms.YBColour.value.set(gYBColour.r, gYBColour.g, gYBColour.b);
	shaderMaterial.uniforms.ZBColour.value.set(gZBColour.r, gZBColour.g, gZBColour.b);
	shaderMaterial.uniforms.XEColour.value.set(gXEColour.r, gXEColour.g, gXEColour.b);
	shaderMaterial.uniforms.YEColour.value.set(gYEColour.r, gYEColour.g, gYEColour.b);
	shaderMaterial.uniforms.ZEColour.value.set(gZEColour.r, gZEColour.g, gZEColour.b);
	shaderMaterial.uniforms.sliceHeight.value = gSliceHeight;
	shaderMaterial.uniforms.juliaStart.value.set(gJuliaLocation.x, gJuliaLocation.y, gJuliaLocation.z);
}

function AnimateJulia() {
	if (gJuliaDirty)
	{
		SetCameraPosition(gJuliaRotation);

		shaderMaterial.uniforms.depthCheck.value = false;
		shaderMaterial.uniforms.juliaMode.value = !gJuliaMain;
		shaderMaterial.uniforms.sliceFractal.value = false;
		shaderMaterial.uniforms.iterations.value = 20;
		shaderMaterial.uniforms.resolution.value.set(500,300);
		SetUniforms();
		shaderMaterial.uniforms.cameraPosition2.value.set(gCameraFrom.x, gCameraFrom.y, gCameraFrom.z);
		shaderMaterial.uniforms.cameraTarget.value.set(gCameraTo.x, gCameraTo.y, gCameraTo.z);
		juliaWindowRenderer.render(scene, camera);
		gJuliaDirty = false;
	}
}

function AnimateOrbitMap() {
	if (gOrbitMapDirty)
	{
		shaderMaterial.uniforms.sliceFractal.value = true;
		shaderMaterial.uniforms.juliaMode.value = gJuliaMain;
		shaderMaterial.uniforms.depthCheck.value = false;
		shaderMaterial.uniforms.iterations.value = 20;
		shaderMaterial.uniforms.resolution.value.set(500,300);
		SetUniforms();
		orbitMapWindowRenderer.render(scene, camera);
		gOrbitMapDirty = false;
	}
}

function interpolateColors(value, color1, color2) {
    // Ensure the value is clamped between 0 and 1
    value = Math.max(0, Math.min(1, value));

    const colorStart = new THREE.Color(color1);
    const colorEnd = new THREE.Color(color2);

    const resultColor = colorStart.clone().lerp(colorEnd, value);
    return resultColor;
}

function AnimateOrbitViewer() {
	if (gOrbitViewDirty)
	{
		if (gOrbitLocation.x!=0.0 || gOrbitLocation.y!=0.0 || gOrbitLocation.z!=0.0)
		{
/* GLSL Code
    vec3 z = pos.xzy;

    float dr = 1.0;
    float r = 0.0;
	float theta, phi;
	
	trap = vec4(abs(z),0.0);

    for (int i = 0; i < maxIterations; i++) {
       r = length(z);
        if (r > escapeBound) break;
		
		float theta = atan(z.y / z.x);
		float phi = asin(z.z / r);
        dr = pow(r, power - 1.0) * power * dr + 1.0;

        // Scale and rotate the point
        float zr = pow(r, power);
        theta = theta * power;
        phi = phi * power;

        // Convert back to cartesian coordinates
        z = zr * vec3(cos(theta) * cos(phi), cos(phi) * sin(theta), sin(phi));
		if (juliaMode)
			z += juliaStart;
        else
			z += pos.xzy;
	    trap = vec4(min(trap.xyz, abs(z)), i);
    }

    return 0.5 * log(r) * r / dr;*/
			points = new Array();
			
			let r;
			const escapeBound = 2.0; // Assuming a common escape bound; adjust if needed
			const juliaMode = false; // Set this based on your needs
			let z = new THREE.Vector3(gOrbitLocation.x, gOrbitLocation.z, gOrbitLocation.y);

			for (var i=0; i<gIterations; i++)
			{
				points[i] = new THREE.Vector3(z.x, z.z, z.y);
				r = z.length();
				if (r > escapeBound) break;

				let theta = Math.atan2(z.y, z.x);  // Note: In JavaScript, atan2(y, x) is the order
				let phi = Math.asin(z.z / r);

				// Scale and rotate the point
				let zr = Math.pow(r, gPower);
				theta = theta * gPower;
				phi = phi * gPower;
				// Convert back to cartesian coordinates
				z.set(
					zr * Math.cos(theta) * Math.cos(phi),
					zr * Math.cos(phi) * Math.sin(theta),
					zr * Math.sin(phi)
				);
				
				if (gJuliaMain)
					z.add(gJuliaLocation);
				else
					z.add(new THREE.Vector3(gOrbitLocation.x, gOrbitLocation.z, gOrbitLocation.y));
			}
			
			while (orbitViewScene.children.length>1)
			{
			 orbitViewScene.remove(orbitViewScene.children[1]);
			}
			
			// create the line object
			const geometry = new THREE.BufferGeometry();
			const vertices = new Float32Array(points.length*3);
			for (i=0; i<points.length; i++)
			{
				vertices[3*i] = points[i].x;
				vertices[3*i+1] = points[i].y;
				vertices[3*i+2] = points[i].z;
			}
			geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
			var colours = new Float32Array(points.length*3);
			for (i=0; i<points.length; i++)
			{
			 colours[3*i] = parseFloat(i) / parseFloat(points.length);
			 colours[3*i+1] = parseFloat(i) / parseFloat(points.length); 
			 colours[3*i+2] = parseFloat(i) / parseFloat(points.length);
			}
			geometry.setAttribute('color', new THREE.BufferAttribute(colours, 3));

			const material = new THREE.LineBasicMaterial({ vertexColors: true });
			const line = new THREE.Line(geometry, material);
			orbitViewScene.add(line);

			for (let i = 0; i < points.length; i ++) {
				const x = points[i].x;
				const y = points[i].y;
				const z = points[i].z;

				// Create the sphere geometry
				const sphereGeometry = new THREE.SphereGeometry(0.05, 8, 8);  // 0.2 is the radius, adjust as needed
				sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
				const startColor = '#ff0000';  // Red
				const endColor = '#0000ff';   // Blue
				const MatColour = interpolateColors(parseFloat(i)/parseFloat(points.length), startColor, endColor);
				sphereMaterial.color.setRGB(MatColour.r, MatColour.g, MatColour.b);

				const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
				sphere.position.set(x, y, z);

				orbitViewScene.add(sphere);
			}
		}

		orbitViewRenderer.render(orbitViewScene, orbitViewCamera);
		gOrbitViewDirty = false;
	}
}

function SetCameraPosition(rotation)
{
	gCameraFrom.x = Math.sin(rotation.x) * Math.cos(rotation.y) * gDistance;
	gCameraFrom.y = Math.sin(rotation.y) * gDistance;
	gCameraFrom.z = Math.cos(rotation.x) * Math.cos(rotation.y) * gDistance;
}

// Render loop
function animate() {
    requestAnimationFrame(animate);
	if (gDirty)
	{
		SetCameraPosition(gRotation);
		
		shaderMaterial.uniforms.power.value = gPower;
		shaderMaterial.uniforms.depthCheck.value = false;
		shaderMaterial.uniforms.juliaMode.value = gJuliaMain;
		shaderMaterial.uniforms.sliceFractal.value = false;
		shaderMaterial.uniforms.iterations.value = gIterations;
		shaderMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
		SetUniforms();
		
	
		shaderMaterial.uniforms.cameraPosition2.value.set(gCameraFrom.x, gCameraFrom.y, gCameraFrom.z);
		shaderMaterial.uniforms.cameraTarget.value.set(gCameraTo.x, gCameraTo.y, gCameraTo.z);
		renderer.render(scene, camera);

		gDirty = false;
	}

	if (document.getElementById("JuliaSelector").hidden == false)
		AnimateJulia();

	if (document.getElementById("OrbitViewer").hidden == false)
		AnimateOrbitViewer();

	if (document.getElementById("OrbitMap").hidden == false)
		AnimateOrbitMap();
}

var renderTarget;

function readBackDepth(x, y) {
	if (!renderer.capabilities.isWebGL2
	 && !renderer.extensions.get('OES_texture_float')) 
	{
	 console.warn("missing capability for floating point textures. bummer");
	 return;
	}
	
	renderTarget = new THREE.WebGLRenderTarget(1, 1, {
	    minFilter: THREE.LinearFilter,
		magFilter: THREE.LinearFilter,
		format: THREE.RGBAFormat,
		type: THREE.FloatType});
	
	shaderMaterial.uniforms.depthCheck.value = true;
	shaderMaterial.uniforms.depthXY.value.set(x, window.innerHeight-y);
	shaderMaterial.uniforms.juliaMode.value = gJuliaMain;
	shaderMaterial.uniforms.sliceFractal.value = false;
	shaderMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
	SetUniforms();

	renderer.setRenderTarget(renderTarget);
	renderer.render(scene, camera);
	renderer.setRenderTarget(null);
	
	const pixelBuffer = new Float32Array(4);  // For RGBA values

	renderer.readRenderTargetPixels(renderTarget, 0, 0, 1, 1, pixelBuffer);
	return pixelBuffer;
}

var juliaWindowRenderer;
var orbitViewRenderer;
var orbitViewScene;
var orbitViewCamera;
var orbitMapWindowRenderer;

function InitialiseSubWindows()
{
	// initialise julia preview window
	const subWindowCanvas = document.getElementById('pickerCanvas');
	juliaWindowRenderer = new THREE.WebGLRenderer({ canvas: subWindowCanvas });
	juliaWindowRenderer.setSize(subWindowCanvas.width, subWindowCanvas.height);

	// initialise orbit map window
	const orbitMapWindowCanvas = document.getElementById('orbitMapCanvas');
	orbitMapWindowRenderer = new THREE.WebGLRenderer({ canvas: orbitMapWindowCanvas });
	orbitMapWindowRenderer.setSize(orbitMapWindowCanvas.width, orbitMapWindowCanvas.height);

	//initialise orbit view window
	const orbitViewCanvas = document.getElementById('orbitCanvas');
	orbitViewRenderer = new THREE.WebGLRenderer({ canvas: orbitViewCanvas });
	orbitViewRenderer.setSize(orbitViewCanvas.width, orbitViewCanvas.height);
	
	// set up a new camera for the orbit viewer
	orbitViewCamera = new THREE.PerspectiveCamera(75, orbitViewCanvas.width / orbitViewCanvas.height, 0.1, 1000);
    orbitViewCamera.position.set(2, 2, 2);
	orbitViewCamera.lookAt(0, 0, 0);
	orbitViewCamera.updateProjectionMatrix();
	
	// set up the orbit viewer
	orbitViewScene = new THREE.Scene();
	const axesHelper = new THREE.AxesHelper(5);
    orbitViewScene.add(axesHelper);
}

let gRotationDragCamFrom = { x: 0, y: 0, z:0 };
let gRotationDragCamTo = { x: 0, y: 0, z:0 };
let gRotation = {x: Math.PI/2, y: 0};
let gJuliaRotation = {x: Math.PI/2, y: 0};
let gDistance = 3;
let gSphereRadius = 1;
let gDragTheta = 0;
let gDragPhi = 0;
let gDragDistance = 1;

function min(a,b)
{
 if (a<b) return a;
 else return b;
}

function AddListeners()
{
	const canvas = renderer.domElement;
	canvas.addEventListener('mousedown', (event) => {
		pixelBuffer = new Float32Array(4);
		pixelBuffer = readBackDepth(event.clientX, event.clientY);

		if (document.getElementById("JuliaSelector").hidden == false && !gJuliaMain)
		{
			if (pixelBuffer[3]>0)
			{
				gJuliaLocation.x = pixelBuffer[0];
				gJuliaLocation.y = pixelBuffer[2];
				gJuliaLocation.z = pixelBuffer[1];
			}
			gJuliaDirty = true;
			gJuliaDragSelection = !gJuliaDragSelection;
		}

		if (pixelBuffer[3]>0)
		{
			let camTo = new THREE.Vector3(pixelBuffer[0]-gCameraFrom.x, pixelBuffer[1]-gCameraFrom.y, pixelBuffer[2]-gCameraFrom.z);
			gDragDistance = camTo.length();
		}
		
		isDragging = true;
		previousMousePosition = { x: event.clientX, y: event.clientY };
	});

	const canvasJulia = juliaWindowRenderer.domElement;
	canvasJulia.addEventListener('mousedown', (event) => {
		isJuliaDragging = true;
		previousMousePosition = { x: event.clientX, y: event.clientY };
	});

	document.addEventListener('mousemove', (event) => {

		if (document.getElementById("OrbitViewer").hidden == false)
		{
			pixelBuffer = new Float32Array(4);
			pixelBuffer = readBackDepth(event.clientX, event.clientY);
			if (pixelBuffer[3]>0)
			{
				gOrbitLocation.x = pixelBuffer[0];
				gOrbitLocation.y = pixelBuffer[1];
				gOrbitLocation.z = pixelBuffer[2];
			}
			gOrbitViewDirty = true;
		}

		if (document.getElementById("OrbitMap").hidden == false)
		{
			pixelBuffer = new Float32Array(4);
			pixelBuffer = readBackDepth(event.clientX, event.clientY);
			if (pixelBuffer[3]>0)
			{
				if (pixelBuffer[1]!=gSliceHeight)
				{
					gSliceHeight = pixelBuffer[1];
					gOrbitMapDirty = true;
				}
			}
		}

		if (gJuliaDragSelection && document.getElementById("JuliaSelector").hidden == false && !gJuliaMain)
		{
			pixelBuffer = new Float32Array(4);
			pixelBuffer = readBackDepth(event.clientX, event.clientY);
			if (pixelBuffer[3]>0)
			{
				gJuliaLocation.x = pixelBuffer[0];
				gJuliaLocation.y = pixelBuffer[2];
				gJuliaLocation.z = pixelBuffer[1];
			}
			gJuliaDirty = true;
		}

		if (isDragging)
		{
			let deltaX = event.clientX - previousMousePosition.x;
			let deltaY = event.clientY - previousMousePosition.y;
			
			gRotation.x -= gDragDistance * deltaX * 0.001;
			gRotation.y += gDragDistance * deltaY * 0.001;
			if (gRotation.y>Math.PI / 2) gRotation.y = Math.PI/2;
			if (gRotation.y<-Math.PI / 2) gRotation.y = -Math.PI/2;

			// Store the new mouse position for the next frame
			previousMousePosition = { x: event.clientX, y: event.clientY };
			gDirty = true;
		}

		if (isJuliaDragging)
		{
			console.log('julia drag');
			let deltaX = event.clientX - previousMousePosition.x;
			let deltaY = event.clientY - previousMousePosition.y;
			
			gJuliaRotation.x -= gDragDistance * deltaX * 0.001;
			gJuliaRotation.y += gDragDistance * deltaY * 0.001;
			if (gJuliaRotation.y>Math.PI / 2) gJuliaRotation.y = Math.PI/2;
			if (gJuliaRotation.y<-Math.PI / 2) gJuliaRotation.y = -Math.PI/2;

			// Store the new mouse position for the next frame
			previousMousePosition = { x: event.clientX, y: event.clientY };
			gJuliaDirty = true;
		}
	});

	document.addEventListener('mouseup', () => {
			console.log('Mouse Up');
		isDragging = false;
		isJuliaDragging = false;
	});

	window.addEventListener('wheel', function(event) {
		var delta = 1;
		var origin = 1;
		pixelBuffer = new Float32Array(4);
		pixelBuffer = readBackDepth(window.innerWidth/2, window.innerHeight/2);
		if (pixelBuffer[3]>0)
		{
			let camTo = new THREE.Vector3(pixelBuffer[0]-gCameraFrom.x, pixelBuffer[1]-gCameraFrom.y, pixelBuffer[2]-gCameraFrom.z);
			delta = camTo.length();
		}
		let camToCentre = new THREE.Vector3(gCameraTo.x - gCameraFrom.x, gCameraTo.y - gCameraFrom.y, gCameraTo.z - gCameraFrom.z);
		origin = camToCentre.length() - delta;

		if (event.deltaY > 0) {
			console.log('Scrolled down');
			delta = delta*1.08;
			gDirty = true;
			gJuliaDirty = true;
		} else if (event.deltaY < 0) {
			console.log('Scrolled up');
			delta = delta*0.94;
			gDirty = true;
			gJuliaDirty = true;
		}
		
		gDistance = origin+delta;

		// Prevent default scrolling behavior if necessary
		// event.preventDefault();
	}, false);
}

// Handle window resize

window.addEventListener('resize', function() {
    var width = window.innerWidth;
    var height = window.innerHeight;
    renderer.setSize(width, height);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();

    shaderMaterial.uniforms.resolution.value.set(width, height);
});

Initialise();

function setGuiBool(id, value)
{
 var guiItem = document.getElementById(id);
 guiItem.checked = value;
}

function setGuiValue(id, value)
{
 var guiItem = document.getElementById(id);
 guiItem.value = value;
}

function setGuiRGB(id, value)
{
 var guiItem = document.getElementById(id);
 let rHex = Math.floor(value.r * 255).toString(16).padStart(2, '0');
 let gHex = Math.floor(value.g * 255).toString(16).padStart(2, '0');
 let bHex = Math.floor(value.b * 255).toString(16).padStart(2, '0');
 guiItem.value = '#'+rHex+gHex+bHex;
}

function guiSetInitialParams()
{
 setGuiValue('power', gPower);
 setGuiValue('iterations', gIterations);
 setGuiBool('ScreenSpaceDE', gScreenSpaceDE);
 setGuiValue('baseEpsilonFactor', gBaseEpsilonFactor);
 setGuiValue('estimateIterations', gEstimateIterations);
 setGuiValue('DEFactor', gDEFactor);
 setGuiBool('sliceFractal', gSliceFractal);
 setGuiBool('xColourEnabled', gXOrbitColour);
 setGuiBool('yColourEnabled', gYOrbitColour);
 setGuiBool('zColourEnabled', gZOrbitColour);
 setGuiRGB('xbColorPicker', gXBColour);
 setGuiRGB('ybColorPicker', gYBColour);
 setGuiRGB('zbColorPicker', gZBColour);
 setGuiRGB('xeColorPicker', gXEColour);
 setGuiRGB('yeColorPicker', gYEColour);
 setGuiRGB('zeColorPicker', gZEColour);
 setGuiBool('HSLBlend', gHSLBlend);
}

function getGuiBool(id)
{
 var guiItem = document.getElementById(id);
 return guiItem.checked;
}

function getGuiFloat(id)
{
 var guiItem = document.getElementById(id);
 return parseFloat(guiItem.value);
}

function getGuiInt(id)
{
 var guiItem = document.getElementById(id);
 return parseInt(guiItem.value);
}

function getGuiRGB(id)
{
 var guiItem = document.getElementById(id);
 let r = parseInt(guiItem.value.substr(1, 2), 16) / 255.99;
 let g = parseInt(guiItem.value.substr(3, 2), 16) / 255.99;
 let b = parseInt(guiItem.value.substr(5, 2), 16) / 255.99;
 return {r, g, b};
}

function guiReadParameters(resize, rerender)
{
 gPower = getGuiFloat('power');
 gIterations = getGuiInt('iterations');
 gScreenSpaceDE = getGuiBool('ScreenSpaceDE');
 gBaseEpsilonFactor = getGuiFloat('baseEpsilonFactor');
 gEstimateIterations = getGuiInt('estimateIterations');
 gDEFactor = getGuiFloat('DEFactor');
 gSliceFractal = getGuiBool('sliceFractal');
 gXOrbitColour = getGuiBool('xColourEnabled');
 gYOrbitColour = getGuiBool('yColourEnabled');
 gZOrbitColour = getGuiBool('zColourEnabled');
 gXBColour = getGuiRGB('xbColorPicker');
 gYBColour = getGuiRGB('ybColorPicker');
 gZBColour = getGuiRGB('zbColorPicker');
 gXEColour = getGuiRGB('xeColorPicker');
 gYEColour = getGuiRGB('yeColorPicker');
 gZEColour = getGuiRGB('zeColorPicker');
 gHSLBlend = getGuiBool('HSLBlend');
 if (rerender) gDirty=true;
}

function guiMenuVisibility(settings, julia, orbit, orbitMap)
{
 document.getElementById("Settings").hidden = !settings;
 document.getElementById("JuliaSelector").hidden = !julia;
 document.getElementById("OrbitViewer").hidden = !orbit;
 document.getElementById("OrbitMap").hidden = !orbitMap;
}

function guiMenuSettings()
{
 guiMenuVisibility(true, false, false, false);
}

function guiMenuJuliaSelector()
{
 guiMenuVisibility(false, true, false, false);
}

function guiMenuOrbitViewer()
{
 guiMenuVisibility(false, false, true, false);
}

function guiMenuOrbitMapViewer()
{
 guiMenuVisibility(false, false, false, true);
}

function guiMenuHide()
{
 guiMenuVisibility(false, false, false);
}

function guiJuliaToMain()
{
 gJuliaMain = !gJuliaMain;
 if (gJuliaMain) document.getElementById("juliaRight").textContent = "<======";
 if (!gJuliaMain) document.getElementById("juliaRight").textContent = "======>";
 gDirty=true;
 gJuliaDirty=true;
 gOrbitMapDirty=true;
 gOrbitViewDirty=true;
}

function Initialise()
{
document.write('\
<DIV class="MBMenu">\
<DIV class="MBMenuOpt" onclick="guiMenuSettings()">Settings</DIV>\
<DIV class="MBMenuOpt" onclick="guiMenuJuliaSelector()">Julia Selector</DIV>\
<DIV class="MBMenuOpt" onclick="guiMenuOrbitViewer()">Orbit Viewer</DIV>\
<DIV class="MBMenuOpt" onclick="guiMenuOrbitMapViewer()">Orbit Map</DIV>\
<DIV class="MBMenuOpt" onclick="guiMenuHide()">Hide</DIV>\
</DIV>\
<DIV class="MBMenu2">\
<A href="http://www.woofractal.com/">WOOFRACTAL.COM</A><BR>Understanding Fractals\
</DIV>\
\
<DIV id="Settings" class="MBPanel">\
<DIV id="stats">\
X : 0<BR>\
Y : 0<BR>\
Zoom : 1\
</DIV>\
<BR>Settings\
<BR><INPUT id="ScreenSpaceDE" checked="true" type="checkbox" onchange="guiReadParameters(false, true)"> Screen Space DE</INPUT>\
<BR><INPUT id="juliaMode" type="checkbox" onchange="guiReadParameters(false, true)"> Julia Mode</INPUT>\
<BR><INPUT id="sliceFractal" type="checkbox" onchange="guiReadParameters(false, true)"> Slice</INPUT>\
<BR><INPUT id="scaleColour" type="checkbox" onchange="guiReadParameters(false, false)"> Scale Colour</INPUT>\
<BR><DIV class="MBLabel" >Power</DIV><INPUT id="power" class="MBInput" onchange="guiReadParameters(false, true)"/></input>\
<BR><DIV class="MBLabel" >MB Iterations</DIV><INPUT id="iterations" class="MBInput" onchange="guiReadParameters(false, true)"/></input>\
<BR><DIV class="MBLabel" >Detail Factor</DIV><INPUT id="baseEpsilonFactor" class="MBInput" onchange="guiReadParameters(false, true)"/></input>\
<BR><DIV class="MBLabel" >DE Iterations</DIV><INPUT id="estimateIterations" class="MBInput" onchange="guiReadParameters(false, true)"/></input>\
<BR><DIV class="MBLabel" >DE Factor</DIV><INPUT id="DEFactor" class="MBInput" onchange="guiReadParameters(false, true)"/></input>\
<BR><INPUT id="fullScreen" type="checkbox" onchange="guiReadParameters(true, true)"> Fullscreen</INPUT>\
<BR><DIV class="MBLabel" >Width</DIV><INPUT id="width" class="MBInput" onchange="guiReadParameters(true, true)"/></input>\
<BR><DIV class="MBLabel" >Height</DIV><INPUT id="height" class="MBInput" onchange="guiReadParameters(true, true)"/></input>\
<BR><INPUT id="xColourEnabled" type="checkbox" onchange="guiReadParameters(false, true)"> X orbit value</INPUT>\
<BR><DIV class="MBLabel" >Colour Gradient</DIV><input class="MBColourInput" type="color" id="xbColorPicker" value="#ff0000" onchange="guiReadParameters(false, true)"><input class="MBColourInput" type="color" id="xeColorPicker" value="#ff0000" onchange="guiReadParameters(false, true)">\
<BR><INPUT id="yColourEnabled" type="checkbox" onchange="guiReadParameters(false, true)"> Y orbit value</INPUT>\
<BR><DIV class="MBLabel" >Colour Gradient</DIV><input class="MBColourInput" type="color" id="ybColorPicker" value="#ff0000" onchange="guiReadParameters(false, true)"><input class="MBColourInput" type="color" id="yeColorPicker" value="#ff0000" onchange="guiReadParameters(false, true)">\
<BR><INPUT id="zColourEnabled" type="checkbox" onchange="guiReadParameters(false, true)"> Z orbit value</INPUT>\
<BR><DIV class="MBLabel" >Colour Gradient</DIV><input class="MBColourInput" type="color" id="zbColorPicker" value="#ff0000" onchange="guiReadParameters(false, true)"><input class="MBColourInput" type="color" id="zeColorPicker" value="#ff0000" onchange="guiReadParameters(false, true)">\
<BR><INPUT id="HSLBlend" type="checkbox" onchange="guiReadParameters(false, true)"> HSL Blending</INPUT>\
</DIV>\
\
<DIV id="JuliaSelector" class="MBPanel">\
<CANVAS style="canvas1" id="pickerCanvas" width=500 height=300 style="border:1px solid #000000;"></CANVAS>\
<BUTTON id="juliaRight" onclick="guiJuliaToMain()">======></BUTTON>\
</DIV>\
\
<DIV id="OrbitViewer" class="MBPanel">\
<CANVAS style="canvas1" id="orbitCanvas" width=500 height=300 style="border:1px solid #000000;"></CANVAS>\
</DIV>\
\
<DIV id="OrbitMap" class="MBPanel">\
<CANVAS style="canvas1" id="orbitMapCanvas" width=500 height=300 style="border:1px solid #000000;"></CANVAS>\
</DIV>');

guiSetInitialParams();
guiMenuHide();
InitialiseSubWindows();
AddListeners();
animate();

}
	</script>
</body>
</html>
