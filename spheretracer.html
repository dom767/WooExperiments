<HTML>
    <HEAD>
    <STYLE>
    * {font-family:verdana;font-size:14;margin:0;padding:0;}
    canvas1 {display:block;}
    div.MBMenu {position:fixed;padding:0px;border-width:0px;background-color:rgba(0,1,0,0.1);width:525px;height:40px;top:50px;left:50px;color:white;}
    .MBMenu2 {position:fixed;font-size:12px;color:#AAA;padding:0px;border-width:0px;background-color:rgba(1,0,1,0.8);width:220px;height:36px;text-align:center;top:41px;right:50px;padding:10px;}
    .MBMenuOpt {float:left;border-width:0px;background-color:rgba(1,0,1,0.8);width:105px;height:40px;color:white;text-align:center;line-height:40px;}
    .MBMenuOpt:hover {background-color:rgba(255,255,255,0.8);color:black;}
    .MBPanel {position:fixed;border-width:0px;padding:10;background-color:rgba(0,0,0,0.5);width:505px;top:90px;left:50px;color:white;}
    .MBLabel {padding:2px;width:120px;float:left;}
    .MBInput {padding:2px;width:120px;style="text-align:right";}
    a {color:#FFF;font-size:16px;text-decoration:none;}
    a:hover {color:#F93;}
    </STYLE>
    
    <SCRIPT>
    
//////////////////////////VEC4/////////////////////////////////
function vec4(x, y, z, w)
{
 this.mX = x;
 this.mY = y;
 this.mZ = z;
 this.mW = w;
}

//////////////////////////VEC3/////////////////////////////////
function vec3(x, y, z)
{
 this.mX = x;
 this.mY = y;
 this.mZ = z;
}
vec3.prototype.sub = function(v) {
  return new vec3(this.mX - v.mX, this.mY - v.mY, this.mZ - v.mZ);
};

vec3.prototype.add = function(v) {
  return new vec3(this.mX + v.mX, this.mY + v.mY, this.mZ + v.mZ);
};

vec3.prototype.addF = function(f) {
  return new vec3(this.mX + f, this.mY + f, this.mZ + f);
};

vec3.prototype.abs = function(v) {
  return new vec3(Math.abs(this.mX), Math.abs(this.mY), Math.abs(this.mZ));
};

vec3.prototype.mul = function(v) {
  return new vec3(this.mX*v, this.mY*v, this.mZ*v);
};

vec3.prototype.neg = function() {
  return new vec3(-this.mX, -this.mY, -this.mZ);
};

vec3.prototype.max = function(f) {
  return new vec3(max(this.mX, f), max(this.mY, f), max(this.mZ, f));
};

// length of vector
vec3.prototype.GetLength = function() {
  return Math.sqrt(this.mX * this.mX + this.mY * this.mY + this.mZ * this.mZ);
};

vec3.prototype.Normalise = function() {
  const length = Math.sqrt(this.mX * this.mX + this.mY * this.mY + this.mZ * this.mZ);
  if (length > 0) {
    this.mX /= length;
    this.mY /= length;
    this.mZ /= length;
  }
  return this;
};

vec3.prototype.Cross = function(v) {
  return new vec3(
    this.mY * v.mZ - this.mZ * v.mY,
    this.mZ * v.mX - this.mX * v.mZ,
    this.mX * v.mY - this.mY * v.mX
  );
};

vec3.prototype.dot = function(v) {
  return this.mX * v.mX + this.mY * v.mY + this.mZ * v.mZ;
};

vec3.prototype.SetSub = function(v1, v2) {
      this.mX = v1.mX - v2.mX;
      this.mY = v1.mY - v2.mY;
      this.mZ = v1.mZ - v2.mZ;
    };

//////////////////////////MAT4/////////////////////////////////
function mat4(m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,m23,m30,m31,m32,m33)
{
 this.m = [
    [m00, m01, m02, m03],
    [m10, m11, m12, m13],
    [m20, m21, m22, m23],
    [m30, m31, m32, m33]
  ];
}

mat4.prototype.MakeIdentity = function()
{
 this.m[0][0] = this.m[1][1] = this.m[2][2] = this.m[3][3] = 1.0;
 this.m[0][1] = this.m[0][2] = this.m[0][3] = 0.0;
 this.m[1][0] = this.m[1][2] = this.m[1][3] = 0.0;
 this.m[2][0] = this.m[2][1] = this.m[2][3] = 0.0;
 this.m[3][0] = this.m[3][1] = this.m[3][2] = 0.0;
}

mat4.prototype.MakeLookAt = function(from, to, up) {
  const zAxis = (to.sub(from)).normalise();
  const xAxis = (up.cross(zAxis)).normalise();
  const yAxis = zAxis.cross(xAxis);

  this.m[0][0] = xAxis.mX;
  this.m[1][0] = xAxis.mY;
  this.m[2][0] = xAxis.mZ;
  this.m[3][0] = -xAxis.dot(from);

  this.m[0][1] = yAxis.mX;
  this.m[1][1] = yAxis.mY;
  this.m[2][1] = yAxis.mZ;
  this.m[3][1] = -yAxis.dot(from);

  this.m[0][2] = zAxis.mX;
  this.m[1][2] = zAxis.mY;
  this.m[2][2] = zAxis.mZ;
  this.m[3][2] = -zAxis.dot(from);

  this.m[0][3] = 0.0;
  this.m[1][3] = 0.0;
  this.m[2][3] = 0.0;
  this.m[3][3] = 1;
}

mat4.prototype.MakeProject = function(fovy, aspect, near, far, framebufferWidth, framebufferHeight) {
 const f = 1.0 / Math.tan(fovy / 2);
 const nf = 1.0 / (near - far);

 this.MakeIdentity();

 this.m[0][0] = (f / aspect);
 this.m[1][1] = f;
 this.m[2][2] = (far + near) * nf;
 this.m[2][3] = -1.0;
 this.m[3][2] = 2.0 * far * near * nf;
 this.m[3][3] = 0.0;
}

mat4.prototype.mul = function(v) {
  const x = this.m[0][0] * v.mX + this.m[1][0] * v.mY + this.m[2][0] * v.mZ + this.m[3][0];
  const y = this.m[0][1] * v.mX + this.m[1][1] * v.mY + this.m[2][1] * v.mZ + this.m[3][1];
  const z = this.m[0][2] * v.mX + this.m[1][2] * v.mY + this.m[2][2] * v.mZ + this.m[3][2];
  return new vec3(x, y, z);
}

mat4.prototype.mulvec4 = function(v) {
  const x = this.m[0][0] * v.mX + this.m[1][0] * v.mY + this.m[2][0] * v.mZ + this.m[3][0];
  const y = this.m[0][1] * v.mX + this.m[1][1] * v.mY + this.m[2][1] * v.mZ + this.m[3][1];
  const z = this.m[0][2] * v.mX + this.m[1][2] * v.mY + this.m[2][2] * v.mZ + this.m[3][2];
  const w = this.m[0][3] * v.mX + this.m[1][3] * v.mY + this.m[2][3] * v.mZ + this.m[3][3];
  return new vec4(x, y, z, w);
}

mat4.prototype.MakeRotationX = function(angle) {
  this.MakeIdentity();
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  this.m[2][2] = cos;
  this.m[2][1] = sin;
  this.m[1][2] = -sin;
  this.m[1][1] = cos;
}

mat4.prototype.MakeRotationY = function(angle) {
  this.MakeIdentity();
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  this.m[0][0] = cos;
  this.m[0][2] = sin;
  this.m[2][0] = -sin;
  this.m[2][2] = cos;
}

mat4.prototype.MakeRotationZ = function(angle) {
  this.MakeIdentity();
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  this.m[1][1] = cos;
  this.m[1][0] = sin;
  this.m[0][1] = -sin;
  this.m[0][0] = cos;
}

mat4.prototype.MakeTranslation = function(vec) {
  this.MakeIdentity();
  this.m[3][0] = vec.mX;
  this.m[3][1] = vec.mY;
  this.m[3][2] = vec.mZ;
}

var gRenderWidth;
var gRenderHeight;
var gRenderCanvas;
var gRenderVideo;
var gFullScreen;
var gDelta;
var gTarget;
var gLightPosition;

function Initialise()
{
    window.addEventListener("resize", ResizeWindow);
    ResizeWindow();

    gPosition = new vec3(20, 0, -20);
    gTarget = new vec3(0,10,0);
    gDelta = 0.0;
    gLightPosition = new vec3(0,30,30);

    Tick();
}

function ResetCanvas()
{
    //gCanvas = document.getElementById("canvas1");
    gContext = gRenderCanvas.getContext("2d");
    width = gRenderCanvas.width;
    height = gRenderCanvas.height;

    // Clear the canvas (black)
    gContext.beginPath();
    gContext.fillStyle = "#000";
    gContext.fillRect(0,0,width,height);
    //gContext.endPath();
//    gContext.clearRect(0, 0, width, height);
}

// Distance Estimators
function min(a, b)
{
    return a<b? a : b;
}

function max(a, b)
{
    return a>b ? a : b;
}

function SDCircle(pos)
{
    return max(pos.mY, max(0,Math.sqrt(pos.mX*pos.mX + pos.mZ*pos.mZ)-100));
}

function SDBox(pos, offset, size)
{
  var q = pos.add(offset).abs().sub(size);//abs(p) - b;
  return q.max(0.0).addF(min(max(q.x,max(q.y,q.z)),0.0)).GetLength();
//  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

function SDSphere(pos, centre, radius)
{
    return centre.sub(pos).GetLength() - radius;
}

function smin(a, b, k)
{
    k *= 1.0;
    var r = Math.exp(-a/k) + Math.exp(-b/k);
    return -k*Math.log(r);
}

function GetDistance(pos)
{
  var toCircle = SDCircle(pos);
  var toSphere = SDSphere(pos, new vec3(0,10,0), 10);
  var toSphere2 = SDSphere(pos, new vec3(14*Math.cos(4*Math.PI * gDelta),14,14*Math.sin(4*Math.PI * gDelta)), 4);
  var toSphere3 = SDSphere(pos, new vec3(14*Math.cos(0.5 + 2*Math.PI * gDelta),6,14*Math.sin(0.5 + 2*Math.PI * gDelta)), 4);
//  var toBox = SDBox(pos, new vec3(0,-6,0), new vec3(7,3,7));

  return min(toCircle, smin(smin(toSphere2,toSphere3,1), toSphere, 1));
}

function GetLightDistance(pos)
{
  var toSphere = SDSphere(pos, new vec3(0,30,30), 7);
  return toSphere;
}

var gHitColour = new vec3(0,0,0);
var gHitObject = -1;

function Trace(position, direction, lighting, depth)
{
  if (depth==0) return false;
 
  var distance = 0;
 
  for (step=0; step<100; step++)
  {
    gHitObject = 0;

    distance = GetDistance(position);
    var distanceLighting;
    
    // check for hits with the objects
    if (distance<0.001)
      gHitObject = 1;

    // check for hit with the lighting objects but not for shadow checks!
    if (lighting)
    {
      distanceLighting = GetLightDistance(position);
      if (distanceLighting<0.001)
        gHitObject = 2;
      distance = min(distance, distanceLighting);
    }

    if (gHitObject>0)
    {
      gHitPosition = position;

      if (lighting)
      {
        if (gHitObject==1)
        {
          var normal = new vec3();
          var delta = 0.005;
          var dx = new vec3(delta, 0, 0);
          var dy = new vec3(0, delta, 0);
          var dz = new vec3(0, 0, delta);

          var normalX = GetDistance(position.add(dx)) - GetDistance(position.sub(dx));
          var normalY = GetDistance(position.add(dy)) - GetDistance(position.sub(dy));
          var normalZ = GetDistance(position.add(dz)) - GetDistance(position.sub(dz));

          var normal = new vec3(normalX, normalY, normalZ);
          normal = normal.Normalise();
          
          var lightDirection = gLightPosition.sub(position).Normalise();
          var diffuse = normal.dot(lightDirection);
          if (diffuse<0) diffuse = 0;

          position = position.add(normal.mul(delta));

          shadow = !Trace(position, lightDirection, false, 2);
          if (!shadow) diffuse = 0;

          var reflectionVec = direction.add(normal.mul(2*normal.dot(direction.neg())));
          reflection = Trace(position, reflectionVec, true, depth-1);
          if (!reflection)
          {
              reflectionCol = BackgroundColour(normal);
          } 
          else
          {
              reflectionCol = gHitColour;
          }

          gHitColour = new vec3(diffuse, diffuse, diffuse);
          gHitColour = gHitColour.add(reflectionCol);
          gHitColour = gHitColour.mul(0.5);

          var hitdelta = gHitPosition.sub(gPosition);
          var fogDistance = hitdelta.GetLength();
          var fogDensity = 1-Math.exp(-0.01*fogDistance);
          var fogColour = new vec3(0,0,0);
          for (f=3; f>=0; f--)
          {
            fogTestPosition = gPosition.add(hitdelta.mul((f+Math.random())/4));
            lightDirection = gLightPosition.sub(position).Normalise();

            //TODO colour should depend on location of light source in some way
            if (!Trace(fogTestPosition, lightDirection, false, 2))
              fogColour = fogColour.add(new vec3(0.25,0.2,0.15));
          }
          gHitColour = fogColour.mul(fogDensity).add(gHitColour.mul(1-fogDensity));
        }
        else
        {
          gHitColour = new vec3(1.0,1.0,1.0);
        }
        return true;
      }
      else
      {
        return true;
      }
    }

    position = position.add(direction.mul(distance));
 }
 return false;
}

function BackgroundColour(dir)
{
 var lightDirection = gLightPosition.sub(gPosition).Normalise();
 var dot = max(0,dir.dot(lightDirection));
 var sunBrightness = 0.5*dot + 10*Math.pow(dot, 16);
 var sunColour = new vec3(1.0, 0.7, 0.4).mul(sunBrightness);

 var retColour = new vec3(1.0 - Math.exp(-sunColour.mX),
 1.0 - Math.exp(-sunColour.mY),
 1.0 - Math.exp(-sunColour.mZ))

return retColour;
}

function crc32(str) {
    var crcTable = window.crcTable || (window.crcTable = (function() {
        var c;
        var crcTable = [];
        for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
                c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
            }
            crcTable[n] = c;
        }
        return crcTable;
    })());

    var crc = 0 ^ (-1);

    for (var i = 0; i < str.length; i++) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
}

function pseudoRandom(value) {
    var hash = crc32(value.toString());
    return (hash % 1000000) / 1000000;
}
function Render()
{
    gContext = gRenderCanvas.getContext("2d");
    gWidth = gRenderCanvas.width;
    gHeight = gRenderCanvas.height;

    for (i=0; i<250; i++)
    {
        gDirection = gTarget.sub(gPosition);
        var to = gDirection.Normalise();
        var up = new vec3(0,1,0);
    
        // create ortonormal basis from to and known up
        var right = gDirection.Cross(up);
        right = right.Normalise();
        up = right.Cross(gDirection);

        var x = Math.random() * gWidth;
        var y = Math.random() * gHeight;

        var dx = (x - gWidth/2) / (gWidth/2);
        var dy = (gHeight/2 - y) / (gWidth/2);

        to = to.add(right.mul(dx));
        to = to.add(up.mul(dy));
        to.Normalise();

        var hit = Trace(gPosition, to, true, 2);

        var retColour = new vec3(0,0,0);
        if (hit)
        {
          retColour = gHitColour;
        }
        else
            retColour = BackgroundColour(to);
    
        gContext.fillStyle = "rgba("+retColour.mX*255+","+retColour.mY*255+","+retColour.mZ*255+",0.5)";

        gContext.fillRect(x-3, y-3, 6, 6);
    }

    // transfer to scratch buffer
    context = gRenderVideo.getContext("2d");
    context.drawImage(gRenderCanvas, 0, 0, gRenderWidth, gRenderHeight, 0, 0, gRenderWidth, gRenderHeight);
    
    // add banding
    context.fillStyle = "rgba(0,0,0,1)";
    context.fillRect(0,0,3,height);
    context.fillRect(gRenderWidth-2,0,3,height);
    context.fillStyle = "rgba(198,198,198,0.7)";
    context.fillRect(3,0,2,height);
    context.fillRect(gRenderWidth-4,0,2,height);

    // add text "PLAY" to the video
    context.font = "bold 20px Courier New";
    context.fillStyle = "rgba(255,255,255,1)";
    context.fillText("PLAY\u25B8", 40, 60);
    
    // add the Date in text format AM/PM 12hr time
    var date = new Date();
    var hours = date.getHours();
    var minutes = date.getMinutes();
    var seconds = date.getSeconds();
    var ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12;
    hours = hours ? hours : 12; // the hour '0' should be '12'
    minutes = minutes < 10 ? '0'+minutes : minutes;
    seconds = seconds < 10 ? '0'+seconds : seconds;
    var strTime = hours + ':' + minutes + ':' + seconds;
    context.fillText(ampm, 40, 250);
    context.fillText(strTime, 90, 250);
    
    // add the Date in text format MONTH DAY YEAR, i.e MAY 08 2024
    var month = date.getMonth();
    var day = date.getDate();
    var year = date.getFullYear();
    var monthNames = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN",
                      "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
    var strDate = day + ' ' + year;
    context.fillText(monthNames[month], 40, 270);
    context.fillText(strDate, 90, 270);

    // glitch it up
    context = gFinalComposite.getContext("2d");
    for (y=0; y<gRenderVideo.height; y++)
    {
      var offset = 0.0;//
      
      // Take a floating point number and convert it into a pseudo-random number between 0 and 1

      var bentBar = gRenderVideo.height*0.04;
      var ewidth = bentBar*0.25 + bentBar*0.5*pseudoRandom(gDelta);//(5 * Math.cos(gDelta*10000));
      if (y<bentBar) offset = ewidth*Math.cos(Math.PI * 0.5 * ((y/bentBar)-1))-ewidth;
      
      var vidy = y;
      var psu = 0.5*Math.PI*pseudoRandom(gDelta);
      offset += 1.4*Math.cos(2*Math.PI*(psu+(1.1*vidy/height))) * Math.cos(2*Math.PI*(psu+(2.1*vidy/height))) * Math.cos(2*Math.PI*(psu+(5.1*vidy/height)));

      context.drawImage(gRenderVideo, offset, y, gRenderWidth, 1, 0, y, gRenderWidth, 1);
      
      var psu2 = pseudoRandom(gDelta+y)
      if (-offset+psu2>1.4 && -offset+psu2<=1.69)
      {
       context.drawImage(gNoiseCanvas, gRenderWidth*pseudoRandom(gDelta+y+3), psu2*gRenderHeight, 8, 1, gRenderWidth*psu2, y, 8, 1);
      }
      if (-offset+psu2>1.7 && -offset+psu2<=1.99)
      {
        var psu3 = pseudoRandom(gDelta+y+3)
        var ew = psu3*100;
       context.drawImage(gNoiseCanvas, gRenderWidth*psu2-ew*0.5, psu2*gRenderHeight, 8+ew, 1, gRenderWidth*psu2-ew*0.5, y, 8+ew, 1);
      }
      if (-offset+psu2>1.99)
       context.drawImage(gNoiseCanvas, 0, psu2*gRenderHeight, gRenderWidth, 1, 0, y, gRenderWidth, 1);
    }  

    // RGB split
    ResetRGB();
    context = gBlankRVideo.getContext("2d");
    context.globalCompositeOperation = "multiply"
    context.drawImage(gFinalComposite, 0, 0, gRenderWidth, gRenderHeight, 0, 0, gRenderWidth, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    
    context = gBlankGVideo.getContext("2d");
    context.globalCompositeOperation = "multiply"
    context.drawImage(gFinalComposite, 0, 0, gRenderWidth, gRenderHeight, 0, 0, gRenderWidth, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    
    context = gBlankBVideo.getContext("2d");
    context.globalCompositeOperation = "multiply"
    context.drawImage(gFinalComposite, 0, 0, gRenderWidth, gRenderHeight, 0, 0, gRenderWidth, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    
    context = gChannelVideo.getContext("2d");
    context.globalCompositeOperation = "lighter"
    context.drawImage(gBlankRVideo, 0, 0, gRenderWidth, gRenderHeight, 0, 0, gRenderWidth, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    context = gChannelVideo.getContext("2d");
    context.globalCompositeOperation = "lighter"
    context.drawImage(gBlankGVideo, 0, 0, gRenderWidth, gRenderHeight, 2, 0, gRenderWidth-4, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    context = gChannelVideo.getContext("2d");
    context.globalCompositeOperation = "lighter"
    context.drawImage(gBlankBVideo, 0, 0, gRenderWidth, gRenderHeight, 4, 0, gRenderWidth-8, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    
    gCanvas = document.getElementById("canvas1");
    context = gCanvas.getContext("2d");
    width = gRenderCanvas.width;
    height = gRenderCanvas.height;
    context.drawImage(gChannelVideo, 0, 0, width, height, 0, 0, gCanvas.width, gCanvas.height);

    // draw a white triangle in the middle of the canvas
    drawMenu();
}

function drawMenu()
{
  // get canvas2 rendercontext
  var cnv = document.getElementById("canvas2");
  var ctx = cnv.getContext("2d");
  var menuwidth = cnv.width;
  var menuheight = cnv.height;
  
  // clear the canvas
  ctx.clearRect(0, 0, menuwidth, menuheight);

  // create an array of vertices for each point on an icosahedron using vec3 class
  const vertices = [
    new vec3(0, 1, 0),
    new vec3(0.894, 0.447, 0),
    new vec3(0.276, 0.447, 0.851),
    new vec3(-0.724, 0.447, 0.526),
    new vec3(-0.724, 0.447, -0.526),
    new vec3(0.276, 0.447, -0.851),
    new vec3(0.724, -0.447, 0.526),
    new vec3(-0.276, -0.447, 0.851),
    new vec3(-0.894, -0.447, 0),
    new vec3(-0.276, -0.447, -0.851),
    new vec3(0.724, -0.447, -0.526),
    new vec3(0, -1, 0)
  ];

  // create a rotation array around the Y axis
  var matRotY = new mat4();
  matRotY.MakeRotationY(gDelta * 2 * Math.PI);
  var matRotX = new mat4();
  matRotX.MakeRotationX(gDelta * 4 * Math.PI);
  var matRotZ = new mat4();
  matRotZ.MakeRotationZ(gDelta * 6 * Math.PI);

  var matTrans = new mat4();
  matTrans.MakeTranslation(new vec3(0,0,5));

  var matProj = new mat4();
  matProj.MakeProject(Math.PI/3.4, menuwidth/menuheight, 0.1, 100, menuwidth, menuheight);

  const transVertices = new Array(12);
  for (i=0; i<12; i++)
  {
    transVertices[i] = matRotY.mul(vertices[i]);
    transVertices[i] = matRotX.mul(transVertices[i]);
    transVertices[i] = matRotZ.mul(transVertices[i]);
    transVertices[i] = matTrans.mul(transVertices[i]);
  }

  const rasterVertices = new Array(12);
  for (i=0; i<12; i++)
  {
    var projvec = matProj.mulvec4(transVertices[i]);
    rasterVertices[i] = new vec3();
    rasterVertices[i].mX = menuwidth*0.5 + menuwidth * projvec.mX / projvec.mW;
    rasterVertices[i].mY = menuheight*0.5 + menuheight * projvec.mY / projvec.mW;
  }
  
  const faces = [
    [0, 2, 1], [0, 3, 2], [0, 4, 3], [0, 5, 4], [0, 1, 5],
    [11, 6, 7], [11, 7, 8], [11, 8, 9], [11, 9, 10], [11, 10, 6],
    [1, 2, 6], [2, 3, 7], [3, 4, 8], [4, 5, 9], [5, 1, 10],
    [6, 2, 7], [7, 3, 8], [8, 4, 9], [9, 5, 10], [10, 1, 6]
  ];

  faces.forEach(face => {
    // calculate the face normal
    var normal = transVertices[face[1]].sub(transVertices[face[0]]).Cross(transVertices[face[2]].sub(transVertices[face[0]])).Normalise();

    // diffuse colour + then add a "specular" highlight
    var dp3 = 0.5*normal.dot(new vec3(0.2,0.2,-1));
    dp3 += Math.pow(normal.dot(new vec3(0.2,0.2,-1)), 5);

    // check for visibility
    var cross = rasterVertices[face[1]].sub(rasterVertices[face[0]]).Cross(rasterVertices[face[2]].sub(rasterVertices[face[0]])).Normalise();
  
    if (cross.mZ<0)
    {
      ctx.beginPath();
      ctx.moveTo(rasterVertices[face[0]].mX, rasterVertices[face[0]].mY);
      ctx.lineTo(rasterVertices[face[1]].mX, rasterVertices[face[1]].mY);
      ctx.lineTo(rasterVertices[face[2]].mX, rasterVertices[face[2]].mY);
      ctx.closePath();
      var colorValue = Math.max(0, Math.min(1, dp3));
      var color = Math.floor(colorValue * 255);
      ctx.fillStyle = "rgb(" + color + "," + color + "," + color + ")";
      ctx.fill();
      ctx.strokeStyle = "black";
      ctx.stroke();
    }
  });
}

var gFrame = 0;
var gLastTime = Date.now();

function Tick()
{
    gDelta += 0.0005;
    if (gDelta>1.0) gDelta -= 1.0;
    gPosition = new vec3(Math.cos((gDelta+0.0)*2*Math.PI)*17, 10, -30);
    
    Render();
    
    setTimeout(Tick, 17);

    if (gFrame%100==0)
        gLastTime = Date.now();
    if (gFrame%100==99)
        console.log("Timer : " + (Date.now() - gLastTime));
    
    gFrame++;
}

function CreateCanvas(fullwidth, settings, width, height, x, y, zoom)
{
if (fullwidth)
{
document.write('\
<DIV style="float: left;">\
<CANVAS style="canvas1" id="canvas1" width="100%" height="100%" style="border:1px solid #000000;"></canvas>\
</DIV>');
gFullScreen = true;
}
else
{
document.write('\
<CANVAS style="canvas1" id="canvas1" width="'+width+'" height="'+height+'" style="border:1px solid #000000;"></canvas>\
');
gFullScreen = false;
}
Initialise();
}

function ResizeWindow()
{
 console.log("ResizeWindow (width="+window.innerWidth+", height="+window.innerHeight+")");
 if (gFullScreen)
 {
  gWidth = window.innerWidth;
  gHeight = window.innerHeight;
  var canvas = document.getElementById('canvas1');
  canvas.width = gWidth;
  canvas.height = gHeight;
 }
 else
 {
  gWidth = gCanvasWidth;
  gHeight = gCanvasHeight;
  var canvas = document.getElementById('canvas1');
  canvas.width = gWidth;
  canvas.height = gHeight;
 }

 gRenderWidth = Math.floor(320*gWidth/gHeight);
 gRenderHeight = 320;
 
 // create an offscreen canvas for our rendering
 gRenderCanvas = document.createElement('canvas');
 gRenderCanvas.width = gRenderWidth;
 gRenderCanvas.height = gRenderHeight;

 gRenderVideo = document.createElement('canvas');
 gRenderVideo.width = gRenderWidth;
 gRenderVideo.height = gRenderHeight;

 gChannelVideo = document.createElement('canvas');
 gChannelVideo.width = gRenderWidth;
 gChannelVideo.height = gRenderHeight;

 gBlankRVideo = document.createElement('canvas');
 gBlankRVideo.width = gRenderWidth;
 gBlankRVideo.height = gRenderHeight;

 gBlankGVideo = document.createElement('canvas');
 gBlankGVideo.width = gRenderWidth;
 gBlankGVideo.height = gRenderHeight;

 gBlankBVideo = document.createElement('canvas');
 gBlankBVideo.width = gRenderWidth;
 gBlankBVideo.height = gRenderHeight;

 gFinalComposite = document.createElement('canvas');
 gFinalComposite.width = gRenderWidth;
 gFinalComposite.height = gRenderHeight;

 gNoiseCanvas = document.createElement('canvas');
 gNoiseCanvas.width = gRenderWidth;
 gNoiseCanvas.height = gRenderHeight;

 // fill gNoiseCanvas with pixel noise
 var context = gNoiseCanvas.getContext("2d");
 var imageData = context.getImageData(0, 0, gRenderWidth, gRenderHeight);
 var data = imageData.data;
 for (var i = 0; i < data.length; i+=4) {
   var rand = Math.random()*255;
   data[i] = rand;
   data[i+1] = rand;
   data[i+2] = rand;
   data[i+3] = 255;
 }
 context.putImageData(imageData, 0, 0);

 ResetRGB();

 ResetCanvas();
}

function ResetRGB()
{
 var context = gBlankRVideo.getContext("2d");
 context.beginPath();
 context.fillStyle = "#7F0F00";
 context.fillRect(0,0,gRenderWidth,gRenderHeight);

 context = gBlankGVideo.getContext("2d");
 context.beginPath();
 context.fillStyle = "#7FDF7F";
 context.fillRect(0,0,gRenderWidth,gRenderHeight);

 context = gBlankBVideo.getContext("2d");
 context.beginPath();
 context.fillStyle = "#000F7F";
 context.fillRect(0,0,gRenderWidth,gRenderHeight);

 context = gChannelVideo.getContext("2d");
 context.beginPath();
 context.fillStyle = "#000000";
 context.fillRect(0,0,gRenderWidth,gRenderHeight);
}

</SCRIPT>

<STYLE>
  .MenuItem {
    right: 20px;
    transform: translateY(-50%);
    text-align: center;
    width: 240px;
    background-color: rgba(0, 0, 0, 0.3);
    color: white;
    font-size: 18px;
    border-radius: 15px;
    padding: 10px;
    border: 1px solid white;
    font-family: 'Playfair Display', serif;
    box-shadow: 10px 6px 6px rgba(0, 0, 0, 0.5);
    transition: background-color 0.3s ease;
  }
  
  .MenuItem:hover {
    background-color: rgba(255, 165, 0, 0.8);
  }
  </STYLE>
  
</HEAD>
<BODY id="body">

<DIV style="position:absolute; top:60; right:60; width:280px; overflow:hidden; border:2px; text-align:left;">
<DIV style="top: 0px; left: 30; text-align: center; width: 240px; background-color: rgba(0, 0, 0, 0.3); color: white; font-size: 18px; border-radius: 15px; padding: 10px; border: 1px solid white; font-family: 'Playfair Display', serif; box-shadow: 10px 6px 6px rgba(0, 0, 0, 0.5);">
WOOFRACTAL.COM  
<BR><BR>
<span style="font-size: 12px;">Mucking about with generative art, mathematics, fractals and graphics</span>
</DIV>
    
<DIV style="top: 100; right: 0;">
<CANVAS id="canvas2" width="260" height="300" style="border:0px solid #000000;"></canvas>
</DIV>
<BR>
<DIV class="MenuItem" style="top: calc(50% + 170px);">
  BIFURCATION  
</DIV>
<BR>
<DIV class="MenuItem" style="top: calc(50% + 230px);">
  MANDELBROT
</DIV>
<BR>
<DIV class="MenuItem" style="top: calc(50% + 290px);">
  MANDELBULB
</DIV>
</DIV>

<script>
CreateCanvas(true, true, 1200, 1000, 0, 0, 0.5);
</script>


</BODY>
</HTML>