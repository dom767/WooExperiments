<HTML>
    <HEAD>
    <STYLE>
    * {font-family:verdana;font-size:14;margin:0;padding:0;}
    canvas1 {display:block;}
    div.MBMenu {position:fixed;padding:0px;border-width:0px;background-color:rgba(0,1,0,0.1);width:525px;height:40px;top:50px;left:50px;color:white;}
    .MBMenu2 {position:fixed;font-size:12px;color:#AAA;padding:0px;border-width:0px;background-color:rgba(1,0,1,0.8);width:220px;height:36px;text-align:center;top:41px;right:50px;padding:10px;}
    .MBMenuOpt {float:left;border-width:0px;background-color:rgba(1,0,1,0.8);width:105px;height:40px;color:white;text-align:center;line-height:40px;}
    .MBMenuOpt:hover {background-color:rgba(255,255,255,0.8);color:black;}
    .MBPanel {position:fixed;border-width:0px;padding:10;background-color:rgba(0,0,0,0.5);width:505px;top:90px;left:50px;color:white;}
    .MBLabel {padding:2px;width:120px;float:left;}
    .MBInput {padding:2px;width:120px;style="text-align:right";}
    a {color:#FFF;font-size:16px;text-decoration:none;}
    a:hover {color:#F93;}
    </STYLE>
    
    <SCRIPT>
    
//////////////////////////VEC3/////////////////////////////////
function vec3(x, y, z)
{
 this.mX = x;
 this.mY = y;
 this.mZ = z;
}
vec3.prototype.sub = function(v) {
  return new vec3(this.mX - v.mX, this.mY - v.mY, this.mZ - v.mZ);
};

vec3.prototype.add = function(v) {
  return new vec3(this.mX + v.mX, this.mY + v.mY, this.mZ + v.mZ);
};

vec3.prototype.addF = function(f) {
  return new vec3(this.mX + f, this.mY + f, this.mZ + f);
};

vec3.prototype.abs = function(v) {
  return new vec3(Math.abs(this.mX), Math.abs(this.mY), Math.abs(this.mZ));
};

vec3.prototype.mul = function(v) {
  return new vec3(this.mX*v, this.mY*v, this.mZ*v);
};

vec3.prototype.neg = function() {
  return new vec3(-this.mX, -this.mY, -this.mZ);
};

vec3.prototype.max = function(f) {
  return new vec3(max(this.mX, f), max(this.mY, f), max(this.mZ, f));
};

// length of vector
vec3.prototype.GetLength = function() {
  return Math.sqrt(this.mX * this.mX + this.mY * this.mY + this.mZ * this.mZ);
};

vec3.prototype.Normalise = function() {
  const length = Math.sqrt(this.mX * this.mX + this.mY * this.mY + this.mZ * this.mZ);
  if (length > 0) {
    this.mX /= length;
    this.mY /= length;
    this.mZ /= length;
  }
  return this;
};

vec3.prototype.Cross = function(v) {
  return new vec3(
    this.mY * v.mZ - this.mZ * v.mY,
    this.mZ * v.mX - this.mX * v.mZ,
    this.mX * v.mY - this.mY * v.mX
  );
};

vec3.prototype.dot = function(v) {
  return this.mX * v.mX + this.mY * v.mY + this.mZ * v.mZ;
};

//////////////////////////MAT4/////////////////////////////////
function mat4(m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,m23,m30,m31,m32,m33)
{
 this.m = [
    [m00, m01, m02, m03],
    [m10, m11, m12, m13],
    [m20, m21, m22, m23],
    [m30, m31, m32, m33]
  ];
}

mat4.prototype.MakeIdentity = function()
{
 this.m[0][0] = this.m[1][1] = this.m[2][2] = this.m[3][3] = 1.0;
 this.m[0][1] = this.m[0][2] = this.m[0][3] = 0.0;
 this.m[1][0] = this.m[1][2] = this.m[1][3] = 0.0;
 this.m[2][0] = this.m[2][1] = this.m[2][3] = 0.0;
 this.m[3][0] = this.m[3][1] = this.m[3][2] = 0.0;
}

mat4.prototype.MakeLookAt = function(from, to, up) {
  const zAxis = (to.sub(from)).normalise();
  const xAxis = (up.cross(zAxis)).normalise();
  const yAxis = zAxis.cross(xAxis);

  this.m[0][0] = xAxis.mX;
  this.m[1][0] = xAxis.mY;
  this.m[2][0] = xAxis.mZ;
  this.m[3][0] = -xAxis.dot(from);

  this.m[0][1] = yAxis.mX;
  this.m[1][1] = yAxis.mY;
  this.m[2][1] = yAxis.mZ;
  this.m[3][1] = -yAxis.dot(from);

  this.m[0][2] = zAxis.mX;
  this.m[1][2] = zAxis.mY;
  this.m[2][2] = zAxis.mZ;
  this.m[3][2] = -zAxis.dot(from);

  this.m[0][3] = 0.0;
  this.m[1][3] = 0.0;
  this.m[2][3] = 0.0;
  this.m[3][3] = 1;
}

mat4.prototype.MakeProject = function(fovy, aspect, near, far, framebufferWidth, framebufferHeight) {
 const f = 1.0 / Math.tan(fovy / 2);
 const nf = 1.0 / (near - far);

 this.MakeIdentity();

 this.m[0][0] = (f / aspect);
 this.m[1][1] = f;
 this.m[2][2] = (far + near) * nf;
 this.m[2][3] = -1.0;
 this.m[3][2] = 2.0 * far * near * nf;
 this.m[3][3] = 0.0;
}

mat4.prototype.mul = function(v) {
  const x = this.m[0][0] * v.mX + this.m[1][0] * v.mY + this.m[2][0] * v.mZ + this.m[3][0];
  const y = this.m[0][1] * v.mX + this.m[1][1] * v.mY + this.m[2][1] * v.mZ + this.m[3][1];
  const z = this.m[0][2] * v.mX + this.m[1][2] * v.mY + this.m[2][2] * v.mZ + this.m[3][2];
  return new vec3(x, y, z);
}

mat4.prototype.mulvec4 = function(v) {
  const x = this.m[0][0] * v.mX + this.m[1][0] * v.mY + this.m[2][0] * v.mZ + this.m[3][0];
  const y = this.m[0][1] * v.mX + this.m[1][1] * v.mY + this.m[2][1] * v.mZ + this.m[3][1];
  const z = this.m[0][2] * v.mX + this.m[1][2] * v.mY + this.m[2][2] * v.mZ + this.m[3][2];
  const w = this.m[0][3] * v.mX + this.m[1][3] * v.mY + this.m[2][3] * v.mZ + this.m[3][3];
  return new vec4(x, y, z, w);
}

var gWidth;
var gHeight;
var gRenderWidth;
var gRenderHeight;
var gRenderCanvas;
var gRenderVideo;
var gFullScreen;
var gDelta;
var gTarget;
var gLightPosition;

function Initialise()
{
    window.addEventListener("resize", ResizeWindow);
    ResizeWindow();

    gPosition = new vec3(20, 0, -20);
    gTarget = new vec3(0,10,0);
    gDelta = 0.0;
    gLightPosition = new vec3(0,30,30);

    Tick();
}

function ResetCanvas()
{
    //gCanvas = document.getElementById("canvas1");
    gContext = gRenderCanvas.getContext("2d");
    width = gRenderCanvas.width;
    height = gRenderCanvas.height;

    // Clear the canvas (black)
    gContext.beginPath();
    gContext.fillStyle = "#000";
    gContext.fillRect(0,0,width,height);
    //gContext.endPath();
//    gContext.clearRect(0, 0, width, height);
}

// Distance Estimators
function min(a, b)
{
    return a<b? a : b;
}

function max(a, b)
{
    return a>b ? a : b;
}

function SDCircle(pos)
{
    return max(pos.mY, max(0,Math.sqrt(pos.mX*pos.mX + pos.mZ*pos.mZ)-100));
}

function SDBox(pos, offset, size)
{
  var q = pos.add(offset).abs().sub(size);//abs(p) - b;
  return q.max(0.0).addF(min(max(q.x,max(q.y,q.z)),0.0)).GetLength();
//  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

function SDSphere(pos, centre, radius)
{
    return centre.sub(pos).GetLength() - radius;
}

function GetDistance(pos)
{
  var toCircle = SDCircle(pos);
  var toSphere = SDSphere(pos, new vec3(0,10,0), 10);
  var toBox = SDBox(pos, new vec3(0,-6,0), new vec3(7,3,7));
  return min(toCircle, min(toBox, toSphere));
}

function GetLightDistance(pos)
{
  var toSphere = SDSphere(pos, new vec3(0,30,30), 7);
  return toSphere;
}

var gHitColour = new vec3(0,0,0);
var gHitObject = -1;

function Trace(position, direction, lighting, depth)
{
    if (depth==0) return false;
    var distance = 0;
 for (step=0; step<100; step++)
 {
  gHitObject = 0;

    distance = GetDistance(position);
    var distanceLighting;
    
    // check for hits with the objects
    if (distance<0.001)
      gHitObject = 1;

    // check for hit with the lighting objects but not for shadow checks!
    if (lighting)
    {
      distanceLighting = GetLightDistance(position);
      if (distanceLighting<0.001)
        gHitObject = 2;
      distance = min(distance, distanceLighting);
    }


    if (gHitObject>0)
    {
      gHitPosition = position;

        if (lighting)
        {
          if (gHitObject==1)
          {
            var normal = new vec3();
            var delta = 0.005;
            var dx = new vec3(delta, 0, 0);
            var dy = new vec3(0, delta, 0);
            var dz = new vec3(0, 0, delta);

            var normalX = GetDistance(position.add(dx)) - GetDistance(position.sub(dx));
            var normalY = GetDistance(position.add(dy)) - GetDistance(position.sub(dy));
            var normalZ = GetDistance(position.add(dz)) - GetDistance(position.sub(dz));

            var normal = new vec3(normalX, normalY, normalZ);
            normal = normal.Normalise();
            
            var lightDirection = gLightPosition.sub(position).Normalise();
            var diffuse = normal.dot(lightDirection);
            if (diffuse<0) diffuse = 0;

            position = position.add(normal.mul(delta));

            shadow = !Trace(position, lightDirection, false, 2);
            if (!shadow) diffuse = 0;

            var reflectionVec = direction.add(normal.mul(2*normal.dot(direction.neg())));
            reflection = Trace(position, reflectionVec, true, depth-1);
            if (!reflection)
            {
                reflectionCol = BackgroundColour(normal);
            } 
            else
            {
                reflectionCol = gHitColour;
            }

            gHitColour = new vec3(diffuse, diffuse, diffuse);
            gHitColour = gHitColour.add(reflectionCol);
            gHitColour = gHitColour.mul(0.5);

            var hitdelta = gHitPosition.sub(gPosition);
            var fogDistance = hitdelta.GetLength();
            var fogDensity = 1-Math.exp(-0.01*fogDistance);
            var fogColour = new vec3(0,0,0);
            for (f=3; f>=0; f--)
            {
                fogTestPosition = gPosition.add(hitdelta.mul((f+Math.random())/4));
                lightDirection = gLightPosition.sub(position).Normalise();
                if (!Trace(fogTestPosition, lightDirection, false, 2))
                 fogColour = fogColour.add(new vec3(0.25,0.2,0.15));
            }   
            gHitColour = fogColour.mul(fogDensity).add(gHitColour.mul(1-fogDensity));
          }
          else
          {
            gHitColour = new vec3(1.0,1.0,1.0);
          }
          return true;
        }
        else
        {
          return true;
        }
    }

    position = position.add(direction.mul(distance));
 }
 return false;
}

function BackgroundColour(dir)
{
 var lightDirection = gLightPosition.sub(gPosition).Normalise();
 var dot = max(0,dir.dot(lightDirection));
 var sunBrightness = 0.5*dot + 10*Math.pow(dot, 16);
 var sunColour = new vec3(1.0, 0.7, 0.4).mul(sunBrightness);

 var retColour = new vec3(1.0 - Math.exp(-sunColour.mX),
 1.0 - Math.exp(-sunColour.mY),
 1.0 - Math.exp(-sunColour.mZ))

return retColour;
}

function crc32(str) {
    var crcTable = window.crcTable || (window.crcTable = (function() {
        var c;
        var crcTable = [];
        for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
                c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
            }
            crcTable[n] = c;
        }
        return crcTable;
    })());

    var crc = 0 ^ (-1);

    for (var i = 0; i < str.length; i++) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
}

function pseudoRandom(value) {
    var hash = crc32(value.toString());
    return (hash % 1000000) / 1000000;
}
function Render()
{
    gContext = gRenderCanvas.getContext("2d");
    gWidth = gRenderCanvas.width;
    gHeight = gRenderCanvas.height;

    for (i=0; i<250; i++)
    {
        gDirection = gTarget.sub(gPosition);
        var to = gDirection.Normalise();
        var up = new vec3(0,1,0);
    
        // create ortonormal basis from to and known up
        var right = gDirection.Cross(up);
        right = right.Normalise();
        up = right.Cross(gDirection);

        var x = Math.random() * gWidth;
        var y = Math.random() * gHeight;

        var dx = (x - gWidth/2) / (gWidth/2);
        var dy = (gHeight/2 - y) / (gWidth/2);

        to = to.add(right.mul(dx));
        to = to.add(up.mul(dy));
        to.Normalise();

        var hit = Trace(gPosition, to, true, 2);

        var retColour = new vec3(0,0,0);
        if (hit)
        {
          retColour = gHitColour;
        }
        else
            retColour = BackgroundColour(to);
    
        gContext.fillStyle = "rgba("+retColour.mX*255+","+retColour.mY*255+","+retColour.mZ*255+",0.5)";

        gContext.fillRect(x-3, y-3, 6, 6);
    }

    // transfer to scratch buffer
    context = gRenderVideo.getContext("2d");
    context.drawImage(gRenderCanvas, 0, 0, gRenderWidth, gRenderHeight, 0, 0, gRenderWidth, gRenderHeight);
    
    // add banding
    context.fillStyle = "rgba(0,0,0,1)";
    context.fillRect(0,0,3,height);
    context.fillRect(gRenderWidth-2,0,3,height);
    context.fillStyle = "rgba(198,198,198,0.7)";
    context.fillRect(3,0,2,height);
    context.fillRect(gRenderWidth-4,0,2,height);

    // add text "PLAY" to the video
    context.font = "bold 20px Courier New";
    context.fillStyle = "rgba(255,255,255,1)";
    context.fillText("PLAY\u25B8", 40, 60);
    
    // add the Date in text format AM/PM 12hr time
    var date = new Date();
    var hours = date.getHours();
    var minutes = date.getMinutes();
    var seconds = date.getSeconds();
    var ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12;
    hours = hours ? hours : 12; // the hour '0' should be '12'
    minutes = minutes < 10 ? '0'+minutes : minutes;
    seconds = seconds < 10 ? '0'+seconds : seconds;
    var strTime = hours + ':' + minutes + ':' + seconds;
    context.fillText(ampm, 40, 250);
    context.fillText(strTime, 90, 250);
    
    // add the Date in text format MONTH DAY YEAR, i.e MAY 08 2024
    var month = date.getMonth();
    var day = date.getDate();
    var year = date.getFullYear();
    var monthNames = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN",
                      "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
    var strDate = day + ' ' + year;
    context.fillText(monthNames[month], 40, 270);
    context.fillText(strDate, 90, 270);

    // glitch it up
    context = gFinalComposite.getContext("2d");
    for (y=0; y<gRenderVideo.height; y++)
    {
      var offset = 0.0;//
      
      // Take a floating point number and convert it into a pseudo-random number between 0 and 1

      var bentBar = gRenderVideo.height*0.04;
      var ewidth = bentBar*0.25 + bentBar*0.5*pseudoRandom(gDelta);//(5 * Math.cos(gDelta*10000));
      if (y<bentBar) offset = ewidth*Math.cos(Math.PI * 0.5 * ((y/bentBar)-1))-ewidth;
      
      var vidy = y;
      var psu = 0.5*Math.PI*pseudoRandom(gDelta);
      offset += 1.4*Math.cos(2*Math.PI*(psu+(1.1*vidy/height))) * Math.cos(2*Math.PI*(psu+(2.1*vidy/height))) * Math.cos(2*Math.PI*(psu+(5.1*vidy/height)));

      context.drawImage(gRenderVideo, offset, y, gRenderWidth, 1, 0, y, gRenderWidth, 1);
      
      var psu2 = pseudoRandom(gDelta+y)
      if (-offset+psu2>1.4 && -offset+psu2<=1.69)
      {
       context.drawImage(gNoiseCanvas, gRenderWidth*pseudoRandom(gDelta+y+3), psu2*gRenderHeight, 8, 1, gRenderWidth*psu2, y, 8, 1);
      }
      if (-offset+psu2>1.7 && -offset+psu2<=1.99)
      {
        var psu3 = pseudoRandom(gDelta+y+3)
        var ew = psu3*100;
       context.drawImage(gNoiseCanvas, gRenderWidth*psu2-ew*0.5, psu2*gRenderHeight, 8+ew, 1, gRenderWidth*psu2-ew*0.5, y, 8+ew, 1);
      }
      if (-offset+psu2>1.99)
       context.drawImage(gNoiseCanvas, 0, psu2*gRenderHeight, gRenderWidth, 1, 0, y, gRenderWidth, 1);
    }  

    // RGB split
    ResetRGB();
    context = gBlankRVideo.getContext("2d");
    context.globalCompositeOperation = "multiply"
    context.drawImage(gFinalComposite, 0, 0, gRenderWidth, gRenderHeight, 0, 0, gRenderWidth, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    
    context = gBlankGVideo.getContext("2d");
    context.globalCompositeOperation = "multiply"
    context.drawImage(gFinalComposite, 0, 0, gRenderWidth, gRenderHeight, 0, 0, gRenderWidth, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    
    context = gBlankBVideo.getContext("2d");
    context.globalCompositeOperation = "multiply"
    context.drawImage(gFinalComposite, 0, 0, gRenderWidth, gRenderHeight, 0, 0, gRenderWidth, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    
    context = gChannelVideo.getContext("2d");
    context.globalCompositeOperation = "lighter"
    context.drawImage(gBlankRVideo, 0, 0, gRenderWidth, gRenderHeight, 0, 0, gRenderWidth, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    context = gChannelVideo.getContext("2d");
    context.globalCompositeOperation = "lighter"
    context.drawImage(gBlankGVideo, 0, 0, gRenderWidth, gRenderHeight, 2, 0, gRenderWidth-4, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    context = gChannelVideo.getContext("2d");
    context.globalCompositeOperation = "lighter"
    context.drawImage(gBlankBVideo, 0, 0, gRenderWidth, gRenderHeight, 4, 0, gRenderWidth-8, gRenderHeight);
    context.globalCompositeOperation = "source-over"
    
    gCanvas = document.getElementById("canvas1");
    context = gCanvas.getContext("2d");
    width = gRenderCanvas.width;
    height = gRenderCanvas.height;
    context.drawImage(gChannelVideo, 0, 0, width, height, 0, 0, gCanvas.width, gCanvas.height);

    gInterlace++;
    if (gInterlace>1) gInterlace=0;
}

var gInterlace = 0;
var gFrame = 0;
var gLastTime = Date.now();

function Tick()
{
    gDelta += 0.0013;
    if (gDelta>1.0) gDelta -= 1.0;
    gPosition = new vec3(Math.cos((gDelta+0.0)*2*Math.PI)*17, 10, -30);
    
    Render();
    
    setTimeout(Tick, 17);

    if (gFrame%100==0)
        gLastTime = Date.now();
    if (gFrame%100==99)
        console.log("Timer : " + (Date.now() - gLastTime));
    
    gFrame++;
}

function CreateCanvas(fullwidth, settings, width, height, x, y, zoom)
{
if (fullwidth)
{
document.write('\
<DIV style="float: left;">\
<CANVAS style="canvas1" id="canvas1" width="100%" height="100%" style="border:1px solid #000000;"></canvas>\
</DIV>');
gFullScreen = true;
}
else
{
document.write('\
<CANVAS style="canvas1" id="canvas1" width="'+width+'" height="'+height+'" style="border:1px solid #000000;"></canvas>\
');
gFullScreen = false;
}
Initialise();
}

function ResizeWindow()
{
 console.log("ResizeWindow (width="+window.innerWidth+", height="+window.innerHeight+")");
 if (gFullScreen)
 {
  gWidth = window.innerWidth;
  gHeight = window.innerHeight;
  var canvas = document.getElementById('canvas1');
  canvas.width = gWidth;
  canvas.height = gHeight;
 }
 else
 {
  gWidth = gCanvasWidth;
  gHeight = gCanvasHeight;
  var canvas = document.getElementById('canvas1');
  canvas.width = gWidth;
  canvas.height = gHeight;
 }

 gRenderWidth = Math.floor(320*gWidth/gHeight);
 gRenderHeight = 320;
 
 // create an offscreen canvas for our rendering
 gRenderCanvas = document.createElement('canvas');
 gRenderCanvas.width = gRenderWidth;
 gRenderCanvas.height = gRenderHeight;

 gRenderVideo = document.createElement('canvas');
 gRenderVideo.width = gRenderWidth;
 gRenderVideo.height = gRenderHeight;

 gChannelVideo = document.createElement('canvas');
 gChannelVideo.width = gRenderWidth;
 gChannelVideo.height = gRenderHeight;

 gBlankRVideo = document.createElement('canvas');
 gBlankRVideo.width = gRenderWidth;
 gBlankRVideo.height = gRenderHeight;

 gBlankGVideo = document.createElement('canvas');
 gBlankGVideo.width = gRenderWidth;
 gBlankGVideo.height = gRenderHeight;

 gBlankBVideo = document.createElement('canvas');
 gBlankBVideo.width = gRenderWidth;
 gBlankBVideo.height = gRenderHeight;

 gFinalComposite = document.createElement('canvas');
 gFinalComposite.width = gRenderWidth;
 gFinalComposite.height = gRenderHeight;

 gNoiseCanvas = document.createElement('canvas');
 gNoiseCanvas.width = gRenderWidth;
 gNoiseCanvas.height = gRenderHeight;

 // fill gNoiseCanvas with pixel noise
 var context = gNoiseCanvas.getContext("2d");
 var imageData = context.getImageData(0, 0, gRenderWidth, gRenderHeight);
 var data = imageData.data;
 for (var i = 0; i < data.length; i+=4) {
   var rand = Math.random()*255;
   data[i] = rand;
   data[i+1] = rand;
   data[i+2] = rand;
   data[i+3] = 255;
 }
 context.putImageData(imageData, 0, 0);

 ResetRGB();

 ResetCanvas();
}

function ResetRGB()
{
 var context = gBlankRVideo.getContext("2d");
 context.beginPath();
 context.fillStyle = "#7F0F00";
 context.fillRect(0,0,gRenderWidth,gRenderHeight);

 context = gBlankGVideo.getContext("2d");
 context.beginPath();
 context.fillStyle = "#7FDF7F";
 context.fillRect(0,0,gRenderWidth,gRenderHeight);

 context = gBlankBVideo.getContext("2d");
 context.beginPath();
 context.fillStyle = "#000F7F";
 context.fillRect(0,0,gRenderWidth,gRenderHeight);

 context = gChannelVideo.getContext("2d");
 context.beginPath();
 context.fillStyle = "#000000";
 context.fillRect(0,0,gRenderWidth,gRenderHeight);
}

</SCRIPT>

</HEAD>
<BODY id="body">

<script>
CreateCanvas(true, true, 1200, 1000, 0, 0, 0.5);
</script>
</BODY>
</HTML>